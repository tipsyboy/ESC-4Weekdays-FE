pipeline {
  agent {
    kubernetes {
      defaultContainer 'node'
      yaml """
apiVersion: v1
kind: Pod
metadata:
  namespace: fourweekdays-jenkins
spec:
  restartPolicy: Never
  containers:
    - name: node
      image: node:22-bullseye
      command: ['cat']
      tty: true
      volumeMounts:
        - name: workspace
          mountPath: /workspace
    - name: kaniko
      image: gcr.io/kaniko-project/executor:debug
      command: ['/busybox/sh','-c','sleep infinity']
      tty: true
      volumeMounts:
        - name: docker-config
          mountPath: /kaniko/.docker
        - name: workspace
          mountPath: /workspace
  volumes:
    - name: workspace
      emptyDir: {}
    - name: docker-config
      secret:
        secretName: dockerhub-cred
        items:
          - key: .dockerconfigjson
            path: config.json
"""
    }
  }

  environment {
    IMAGE_NAME = 'tipsyboy/frontend'
    IMAGE_TAG = "${BUILD_NUMBER}"
    SKIP_BUILD = 'false'
  }

  stages {
    stage('GitHub Checkout') {
      steps {
        echo "Jenkins 컨테이너 내부 - GitHub Checkout 이후에 배포 브랜치에서 프로젝트를 Clone한다."
        container('node') {
          echo "Cloning Repository"
          checkout([$class: 'GitSCM',
            branches: [[name: '*/release']],
            userRemoteConfigs: [[url: 'https://github.com/beyond-sw-camp/be17-fin-ESC-4Weekdays-FE']]
          ])
        }
      }
    }

    stage('Check Changes for Build') {
      steps {
        script {
          echo "Build 파일이 이전 버전과 차이점을 파악하고 차이점이 있는 경우에만 빌드한다."
          def diff = sh(
            script: "git diff --name-only HEAD~1 HEAD 2>/dev/null | grep -E 'package.json|Dockerfile|src/' || true",
            returnStdout: true
          ).trim()

          if (diff == "") {
            echo "코드 변경 없음 → Docker 이미지 빌드 스킵."
            currentBuild.description = "No changes detected, skipped build"
            env.SKIP_BUILD = 'true'
          } else {
            echo "변경 감지됨 → 빌드 진행"
            env.SKIP_BUILD = 'false'
          }
        }
      }
    }

    stage('Node.js Build') {
      when { expression { return env.SKIP_BUILD != 'true' } }
      steps {
        echo "Node.js를 통해 프론트 코드를 빌드한다."
        container('node') {
          sh '''
            ls -la ${WORKSPACE}
            npm ci
            npm run build
          '''
        }
      }
    }

    stage('Build & Push Docker Image with Kaniko') {
      when { expression { return env.SKIP_BUILD != 'true' } }
      steps {
        echo "Kaniko를 통해 빌드하고 빌드한 image를 DockerHub로 Push한다."
        container('kaniko') {
          sh """
            /kaniko/executor \
              --context=${WORKSPACE} \
              --dockerfile=${WORKSPACE}/Dockerfile \
              --destination=${IMAGE_NAME}:${IMAGE_TAG} \
              --destination=${IMAGE_NAME}:latest \
              --cache=true \
              --cache-repo=${IMAGE_NAME}-cache \
              --snapshotMode=redo
          """
        }
      }
    }

    stage('Deploy to Kubernetes') {
      when {
        expression {
          currentBuild.result == null || currentBuild.result == 'SUCCESS'
        }
      }
      steps {
        echo "Blue-Green 배포 방식을 사용해서 K8s로 배포한다."
        script {
          sshPublisher(
            publishers: [
              sshPublisherDesc(
                configName: 'K8S_MASTER',
                verbose: true,
                transfers: [
                  sshTransfer(
                    execCommand: '''
                      if kubectl get svc frontend-svc -n fourweekdays-front -o wide | grep -q "green"; then
                        CURRENT_VER="green"
                        NEXT_VER="blue"
                      else
                        CURRENT_VER="blue"
                        NEXT_VER="green"
                      fi

                      echo "=========================================="
                      echo "현재 버전: ${CURRENT_VER}"
                      echo "배포 버전: ${NEXT_VER}"
                      echo "이미지: tipsyboy/frontend:${BUILD_NUMBER}"
                      echo "=========================================="

                      cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: vue-deployment-${NEXT_VER}
  namespace: fourweekdays-front
spec:
  selector:
    matchLabels:
      type: app
      ver: ${NEXT_VER}
  replicas: 2
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        type: app
        ver: ${NEXT_VER}
    spec:
      containers:
      - name: container
        image: tipsyboy/frontend:${BUILD_NUMBER}
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 15
          periodSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 15
          periodSeconds: 5
          successThreshold: 2
          failureThreshold: 3
      terminationGracePeriodSeconds: 10
EOF

                      echo "##### Deployment 생성 완료 #####"

                      kubectl rollout status deployment/vue-deployment-${NEXT_VER} -n fourweekdays-front --timeout=300s || exit 1

                      echo "##### Rollout 완료 - 헬스체크 대기 중 #####"

                      for i in {1..6}; do
                        READY=$(kubectl get deployment vue-deployment-${NEXT_VER} -n fourweekdays-front -o jsonpath='{.status.readyReplicas}')
                        REPLICAS=$(kubectl get deployment vue-deployment-${NEXT_VER} -n fourweekdays-front -o jsonpath='{.spec.replicas}')
                        if [ -n "${READY}" ] && [ "${READY}" = "${REPLICAS}" ]; then
                          echo "##### 헬스체크 성공 (${READY}/${REPLICAS}) #####"
                          break
                        fi
                        echo "대기 중... ($i/6) - Ready: ${READY:-0}/${REPLICAS:-?}"
                        sleep 10
                      done

                      if [ -z "${READY}" ] || [ "${READY}" != "${REPLICAS}" ]; then
                        echo "##### 헬스체크 실패 - 배포 중단 #####"
                        exit 1
                      fi

                      echo "##### Service 전환 시작 #####"

                      cat > /tmp/frontend-service-patch.json <<PATCH
{
  "spec": {
    "selector": {
      "type": "app",
      "ver": "${NEXT_VER}"
    }
  }
}
PATCH

                      kubectl patch service frontend-svc -n fourweekdays-front --type=merge --patch-file=/tmp/frontend-service-patch.json

                      sleep 5

                      ACTUAL_VER=$(kubectl get service frontend-svc -n fourweekdays-front -o jsonpath='{.spec.selector.ver}')

                      if [ "${ACTUAL_VER}" != "${NEXT_VER}" ]; then
                        echo "##### 경고: Service selector가 변경되지 않음 (예상: ${NEXT_VER}, 실제: ${ACTUAL_VER}) #####"
                        echo "##### kubectl set selector로 재시도 중... #####"

                        kubectl set selector service frontend-svc -n fourweekdays-front "type=app,ver=${NEXT_VER}"
                        sleep 5

                        ACTUAL_VER=$(kubectl get service frontend-svc -n fourweekdays-front -o jsonpath='{.spec.selector.ver}')
                        if [ "${ACTUAL_VER}" != "${NEXT_VER}" ]; then
                          echo "##### 치명적 오류: Service 전환 완전 실패 #####"
                          exit 1
                        fi
                      fi

                      echo "##### Service 전환 확인됨: ${ACTUAL_VER} #####"
                      kubectl get service frontend-svc -n fourweekdays-front -o wide

                      echo "##### 서비스 안정화 대기 중 (30초) #####"
                      sleep 30

                      if kubectl get deployment vue-deployment-${CURRENT_VER} -n fourweekdays-front 2>/dev/null; then
                        kubectl scale deployment vue-deployment-${CURRENT_VER} -n fourweekdays-front --replicas=0
                        echo "##### 이전 버전(${CURRENT_VER}) 스케일 0으로 변경함 #####"
                      else
                        echo "##### 첫 배포 - 이전 버전 없음 #####"
                      fi

                      echo "=========================================="
                      echo "배포 완료: tipsyboy/frontend:${BUILD_NUMBER}"
                      echo "현재 활성 버전: ${NEXT_VER}"
                      echo "Service selector 확인: ${ACTUAL_VER}"
                      echo "=========================================="
                    '''
                  )
                ]
              )
            ]
          )
        }
      }
    }
  }

  post {
    failure {
      echo "Jenkins 파이프라인 실패 - 배포가 중단되었습니다."
      echo "실패한 스테이지: ${env.STAGE_NAME}"
      script {
        sendDiscordNotification('FAILURE')
      }
    }
    success {
      echo "Jenkins 파이프라인 성공 - 배포 완료"
      script {
        sendDiscordNotification('SUCCESS')
      }
    }
    always {
      echo "빌드 번호: ${BUILD_NUMBER}, 결과: ${currentBuild.result}"
    }
  }
}


def sendDiscordNotification(String status) {
  def color = status == 'SUCCESS' ? '3066993' : '15158332'
  def emoji = status == 'SUCCESS' ? '✅' : '❌'
  def message = status == 'SUCCESS' ? '배포 성공' : '배포 실패'

  def payload = """
  {
    "embeds": [{
      "title": "${emoji} Frontend CI/CD ${message}",
      "description": "**빌드 번호:** ${BUILD_NUMBER}\\n**상태:** ${status}\\n**브랜치:** release",
      "color": ${color},
      "fields": [
        {
          "name": "이미지",
          "value": "${IMAGE_NAME}:${IMAGE_TAG}",
          "inline": false
        }
      ],
      "timestamp": "${new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone('UTC'))}"
    }]
  }
  """

  withCredentials([string(credentialsId: 'discord-webhook-front', variable: 'WEBHOOK_URL')]) {
    sh '''
      curl -H "Content-Type: application/json" \
           -d \'''' + payload + '''\' \
           "${WEBHOOK_URL}"
    '''
  }
}